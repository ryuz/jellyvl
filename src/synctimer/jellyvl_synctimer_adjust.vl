
// 調整機構
module synctimer_adjust #(
    parameter TIMER_WIDTH    : u32 = 32                   , // タイマのbit幅
    parameter CYCLE_WIDTH    : u32 = 32                   , // 自クロックサイクルカウンタのbit数
    parameter ERROR_WIDTH    : u32 = 32                   , // 誤差計算時のbit幅
    parameter ERROR_Q        : u32 = 8                    , // 誤差計算時に追加する固定小数点数bit数
    parameter ADJUST_WIDTH   : u32 = CYCLE_WIDTH + ERROR_Q, // 補正周期のbit幅
    parameter ADJUST_Q       : u32 = ERROR_Q              , // 補正周期に追加する固定小数点数bit数
    parameter LPF_GAIN_CYCLE : u32 = 6                    , // 自クロックサイクルカウントLPFの更新ゲイン(1/2^N)
    parameter LPF_GAIN_PERIOD: u32 = 6                    , // 周期補正のLPFの更新ゲイン(1/2^N)
    parameter LPF_GAIN_PHASE : u32 = 6                    , // 位相補正のLPFの更新ゲイン(1/2^N)
    parameter DEBUG          : bit = 1'b0                 ,
    parameter SIMULATION     : bit = 1'b0                 ,
) (
    reset: input logic,
    clk  : input logic,

    param_adjust_min: input signed logic<ERROR_WIDTH>,
    param_adjust_max: input signed logic<ERROR_WIDTH>,

    current_time: input logic<TIMER_WIDTH>,

    correct_override: input logic             ,
    correct_time    : input logic<TIMER_WIDTH>,
    correct_valid   : input logic             ,

    adjust_sign : output logic,
    adjust_valid: output logic,
    adjust_ready: input  logic,
) {

    localparam CYCLE_Q: u32 = LPF_GAIN_CYCLE;


    // type
    localparam t_time   : type = logic<TIMER_WIDTH>;
    localparam t_count  : type = logic<CYCLE_WIDTH>;
    localparam t_cycle  : type = logic<CYCLE_WIDTH + CYCLE_Q>;
    localparam t_error  : type = signed logic<ERROR_WIDTH + ERROR_Q>;
    localparam t_error_u: type = logic<ERROR_WIDTH + ERROR_Q>;
    localparam t_adjust : type = logic<ADJUST_WIDTH + ADJUST_Q>;


    // -------------------------------------
    //  一周期の自クロックのサイクル数推定
    // -------------------------------------

    // サイクルカウント
    var count_cycle : t_count;
    var count_enable: logic  ;
    var count_valid : logic  ;
    always_ff (clk, reset) {
        if_reset {
            count_cycle  = 'x;
            count_enable = 1'b0;
        } else {
            count_cycle += 1 as t_count;
            if correct_valid {
                count_cycle  = 1 as t_count;
                count_enable = 1'b1;
            }
        }
    }
    assign count_valid = correct_valid & count_enable;


    // １周期のサイクル数予測
    var cycle_observe_t        : t_cycle; // サイクル数の観測値
    var cycle_observe_t_en     : logic  ;
    var cycle_predict_t        : t_cycle; // サイクル数の観測値
    var cycle_predict_t_en     : logic  ;
    var cycle_predict_t_gain   : t_cycle; // 位相誤差の予測値にゲインを掛けたもの
    var cycle_predict_t_gain_en: logic  ;
    var cycle_estimate_t       : t_cycle; // 位相誤差の推定値
    var cycle_estimate_t_en    : logic  ;
    var cycle_estimate_t0      : t_cycle; // １つ前の位相誤差の推定値
    var cycle_estimate_t0_en   : logic  ;

    assign cycle_predict_t    = cycle_estimate_t0;
    assign cycle_predict_t_en = cycle_estimate_t0_en;

    always_ff (clk, reset) {
        if_reset {
            cycle_observe_t         = 'x;
            cycle_observe_t_en      = 1'b0;
            cycle_predict_t_gain    = 'x;
            cycle_predict_t_gain_en = 1'b0;
            cycle_estimate_t        = 'x;
            cycle_estimate_t_en     = 1'b0;
            cycle_estimate_t0       = 'x;
            cycle_estimate_t0_en    = 1'b0;
        } else {
            if count_valid {
                // 観測値ラッチ
                cycle_observe_t    = count_cycle as t_cycle <<< CYCLE_Q;
                cycle_observe_t_en = count_enable;

                // １つ前の値保存
                cycle_estimate_t0    = cycle_estimate_t;
                cycle_estimate_t0_en = cycle_estimate_t_en;
            }

            // LPFをかけて推定値とする
            cycle_predict_t_gain    = cycle_predict_t - (cycle_predict_t >>> CYCLE_Q);
            cycle_predict_t_gain_en = cycle_predict_t_en;
            if cycle_observe_t_en {
                if cycle_predict_t_gain_en {
                    cycle_estimate_t = cycle_predict_t_gain + (cycle_observe_t >>> CYCLE_Q);
                } else {
                    cycle_estimate_t = cycle_observe_t; // 初回のみ計測値そのまま
                }
                cycle_estimate_t_en = cycle_observe_t_en;
            }
        }
    }



    // -------------------------------------
    //  時計の誤差修正
    // -------------------------------------

    // 誤差推定
    var error_observe_x        : t_error   ; // 位相誤差の観測値
    var error_observe_x_en     : logic     ;
    var error_predict_x        : t_error   ; // 位相誤差の予測値
    var error_predict_x_en     : logic     ;
    var error_predict_x_gain   : t_error   ; // 位相誤差の予測値にゲインを掛けたもの
    var error_predict_x_gain_en: logic     ;
    var error_estimate_x       : t_error   ; // 位相誤差の推定値
    var error_estimate_x_en    : logic     ;
    var error_estimate_x0      : t_error   ; // １つ前の位相誤差の推定値
    var error_estimate_x0_en   : logic     ;
    var error_estimate_xx      : t_error   ;
    var error_estimate_xx_en   : logic     ;
    var error_observe_v        : t_error   ; // 周期誤差の観測値
    var error_observe_v_en     : logic     ;
    var error_predict_v        : t_error   ; // 位相誤差の予測値
    var error_predict_v_en     : logic     ;
    var error_predict_v_gain   : t_error   ; // 周期誤差の予測値にゲインを掛けたもの
    var error_predict_v_gain_en: logic     ;
    var error_estimate_v       : t_error   ; // 周期誤差の推定値
    var error_estimate_v_en    : logic     ;
    var error_estimate_v0      : t_error   ; // １つ前の周期誤差の推定値
    var error_estimate_v0_en   : logic     ;
    var error_adjust_total     : t_error   ;
    var error_adjust_value     : t_error   ; // 制御量(一周期の補正量)
    var error_adjust_total_en  : logic     ;
    var error_stage            : logic  <8>;
    var error_valid            : logic     ;

    var limit_adjust_min: t_error;
    var limit_adjust_max: t_error;
    assign limit_adjust_min = param_adjust_min as t_error <<< ERROR_Q;
    assign limit_adjust_max = param_adjust_max as t_error <<< ERROR_Q;

    assign error_predict_v    = error_estimate_v0; // 周期予測はひとつ前の推定値と同じ
    assign error_predict_v_en = error_estimate_v0_en;

    var current_error: t_time;
    assign current_error = correct_time - current_time;

    always_ff (clk, reset) {
        if_reset {
            error_observe_x         = 'x;
            error_observe_x_en      = 1'b0;
            error_predict_x         = 'x;
            error_predict_x_en      = 1'b0;
            error_predict_x_gain    = 'x;
            error_predict_x_gain_en = 1'b0;
            error_estimate_x        = 'x;
            error_estimate_x_en     = 1'b0;
            error_estimate_x0       = 'x;
            error_estimate_x0_en    = 1'b0;
            error_estimate_xx       = 'x;
            error_estimate_xx_en    = 1'b0;
            error_observe_v         = 'x;
            error_observe_v_en      = 1'b0;
            error_predict_v_gain    = 'x;
            error_predict_v_gain_en = 1'b0;
            error_estimate_v        = 'x;
            error_estimate_v_en     = 1'b0;
            error_estimate_v0       = 'x;
            error_estimate_v0_en    = 1'b0;
            error_adjust_total      = 'x;
            error_adjust_total_en   = 1'b0;
            error_adjust_value      = '0;
            error_stage             = '0;
            error_valid             = 1'b0;
        } else {
            error_stage <<= 1;

            if correct_valid {
                error_stage[0] = 1'b1;

                if correct_override {
                    // 時刻上書き時
                    error_observe_x         = '0;
                    error_observe_x_en      = 1'b1;
                    error_predict_x         = 'x;
                    error_predict_x_en      = 1'b0;
                    error_predict_x_gain    = 'x;
                    error_predict_x_gain_en = 1'b0;
                    error_estimate_x        = 'x;
                    error_estimate_x_en     = 1'b0;
                    error_estimate_x0       = 'x;
                    error_estimate_x0_en    = 1'b0;
                    error_estimate_xx       = 'x;
                    error_estimate_xx_en    = 1'b0;
                    error_observe_v         = 'x;
                    error_observe_v_en      = 1'b0;
                    error_predict_v_gain    = 'x;
                    error_predict_v_gain_en = 1'b0;
                    error_estimate_v        = 'x;
                    error_estimate_v_en     = 1'b0;
                    error_estimate_v0       = 'x;
                    error_estimate_v0_en    = 1'b0;
                    error_adjust_total      = 'x;
                    error_adjust_total_en   = 1'b0;
                    error_adjust_value      = '0;
                } else {
                    // 観測値ラッチ
                    error_observe_x    = current_error as t_error <<< ERROR_Q;
                    error_observe_x_en = 1'b1;

                    // 1つ前の予測保存
                    error_estimate_x0    = error_estimate_x;
                    error_estimate_x0_en = error_estimate_x_en;

                    error_estimate_v0    = error_estimate_v;
                    error_estimate_v0_en = error_estimate_v_en;
                }
            }

            if error_stage[0] {
                error_estimate_xx    = error_estimate_x0 - error_adjust_value;
                error_estimate_xx_en = error_estimate_x0_en;
            }
            
            if error_stage[1] {
                // 位相ずれ予測
//              error_predict_x    = error_estimate_x0 + error_estimate_v0 - error_adjust_value;
                error_predict_x    = error_estimate_xx + error_estimate_v0;
                error_predict_x_en = error_estimate_xx_en & error_estimate_v0_en;
            }

            if error_stage[2] {
                // LPF用ゲイン計算
                error_predict_x_gain    = error_predict_x - (error_predict_x >>> LPF_GAIN_PHASE);
                error_predict_x_gain_en = error_predict_x_en;
            }

            if error_stage[3] {
                // 位相ずれ推定
                if error_observe_x_en {
                    if error_predict_x_gain_en {
                        error_estimate_x = error_predict_x_gain + (error_observe_x >>> LPF_GAIN_PHASE);
                    } else {
                        error_estimate_x = error_observe_x;
                    }
                    error_estimate_x_en = 1'b1;
                }
            }

            if error_stage[4] {
                // 周期ずれ予測
                error_observe_v    = error_estimate_x - error_estimate_xx; // (error_estimate_x0 - error_adjust_value);
                error_observe_v_en = error_estimate_x_en && error_estimate_xx_en;

                // LPF用ゲイン計算
                error_predict_v_gain    = error_predict_v - (error_predict_v >>> LPF_GAIN_PERIOD);
                error_predict_v_gain_en = error_predict_v_en;
            }

            if error_stage[5] {
                // 周期ずれ推定
                if error_observe_v_en {
                    if error_predict_v_gain_en {
                        error_estimate_v = error_predict_v_gain + (error_observe_v >>> LPF_GAIN_PHASE);
                    } else {
                        error_estimate_v = error_observe_v;
                    }
                    error_estimate_v_en = 1'b1;
                }
            }

            if error_stage[6] {
                // 制御量合計
                error_adjust_total    = error_estimate_x + error_estimate_v;
                error_adjust_total_en = error_estimate_x_en && error_estimate_v_en;
            }

            error_valid = 1'b0;
            if error_stage[7] {
                // limitter
                if error_adjust_total_en {
                    error_adjust_value = error_adjust_total;
                    if error_adjust_total <: limit_adjust_min {
                        error_adjust_value = limit_adjust_min;
                    }
                    if error_adjust_total >: limit_adjust_max {
                        error_adjust_value = limit_adjust_max;
                    }
                    error_valid = 1'b1;
                }
            }
        }
    }



    // -------------------------------------
    //  調整信号の間隔計算
    // -------------------------------------

    var div_calc_sign  : logic    ;
    var div_calc_zero  : logic    ;
    var div_calc_error : t_error_u;
    var div_calc_cycle : t_cycle  ;
    var div_calc_enable: logic    ;
    var div_calc_valid : logic    ;

    always_ff (clk, reset) {
        if_reset {
            div_calc_sign   = 'x;
            div_calc_zero   = 'x;
            div_calc_error  = 'x;
            div_calc_cycle  = 'x;
            div_calc_enable = 1'b0;
            div_calc_valid  = 1'b0;
        } else {
            if error_valid {
                div_calc_sign  = error_adjust_value <: 0;
                div_calc_zero  = error_adjust_value == 0;
                div_calc_error = if error_adjust_value <: 0 {
                    (-error_adjust_value) as t_error_u
                } else {
                    error_adjust_value as t_error_u
                };
                div_calc_cycle  = cycle_estimate_t;
                div_calc_enable = 1'b1;
            }
            div_calc_valid = error_valid;
        }
    }


    // divider
    localparam t_cycle_q: type = logic<CYCLE_WIDTH + ERROR_Q + ADJUST_Q>;

    function CycleToError (
        cycle: input t_cycle,
    ) -> t_cycle_q {
        if ERROR_Q + ADJUST_Q >: CYCLE_Q {
            return cycle as t_cycle_q << (ERROR_Q + ADJUST_Q - CYCLE_Q);
        } else {
            return cycle as t_cycle_q >> (CYCLE_Q - ERROR_Q - ADJUST_Q);
        }
    }

    var div_quotient : t_adjust;
    var div_remainder: t_error ;
    var div_valid    : logic   ;

    var tmp_ready: logic;
    inst i_divider_unsigned_multicycle: divider_unsigned_multicycle #(
        DIVIDEND_WIDTH: CYCLE_WIDTH + ERROR_Q + ADJUST_Q,
        DIVISOR_WIDTH : ERROR_WIDTH + ERROR_Q           ,
        QUOTIENT_WIDTH: ADJUST_WIDTH + ADJUST_Q         ,
    ) (
        reset: reset,
        clk  : clk  ,
        cke  : 1'b1 ,

        s_dividend: CycleToError(div_calc_cycle),
        s_divisor : div_calc_error              ,
        s_valid   : div_calc_valid              ,
        s_ready   : tmp_ready                   ,

        m_quotient : div_quotient ,
        m_remainder: div_remainder,
        m_valid    : div_valid    ,
        m_ready    : 1'b1         ,
    );


    // adjust parameter
    localparam ADJ_STEP: t_adjust = (1 << ADJUST_Q) as t_adjust;

    var adj_param_zero  : logic   ;
    var adj_param_sign  : logic   ;
    var adj_param_period: t_adjust;
    var adj_param_valid : logic   ;
    var adj_param_ready : logic   ;

    always_ff (clk, reset) {
        if_reset {
            adj_param_zero   = 1'b1;
            adj_param_sign   = 1'bx;
            adj_param_period = 'x;
            adj_param_valid  = 1'b0;
        } else {
            if adj_param_ready {
                adj_param_valid = 1'b0;
            }

            if div_valid {
                if div_calc_zero {
                    adj_param_zero   = 1'b1;
                    adj_param_sign   = 1'b0;
                    adj_param_period = '0;
                    adj_param_valid  = !adj_param_zero; // 変化があれば発行
                } else {
                    adj_param_zero   = div_calc_zero;
                    adj_param_sign   = div_calc_sign;
                    adj_param_period = div_quotient - ADJ_STEP;
                    adj_param_valid  = adj_param_zero || ((div_quotient - ADJ_STEP) != adj_param_period);
                }
            }
        }
    }

    // adjuster
    var adj_calc_zero  : logic   ;
    var adj_calc_sign  : logic   ;
    var adj_calc_period: t_adjust;
    var adj_calc_count : t_adjust;
    var adj_calc_next  : t_adjust;
    var adj_calc_valid : logic   ;

    always_ff (clk, reset) {
        if_reset {
            adj_calc_zero   = 1'b1;
            adj_calc_sign   = 'x;
            adj_calc_period = '0;
            adj_calc_count  = 'x;
            adj_calc_next   = 'x;
            adj_calc_valid  = 1'b0;
        } else {

            // adj_param_valid は連続で来ない、period は2以上の前提で事前計算
            adj_calc_count += (1 << ADJUST_Q) as t_adjust;
            adj_calc_next  =  adj_calc_count - adj_calc_period;
            adj_calc_valid =  adj_calc_count >= adj_calc_period || adj_calc_zero;

            if adj_calc_valid {
                if adj_param_valid {
                    adj_calc_zero   = adj_param_zero;
                    adj_calc_sign   = adj_param_sign;
                    adj_calc_period = adj_param_period;
                    adj_calc_count  = '0;
                } else {
                    adj_calc_count = adj_calc_next;
                }
                adj_calc_valid = 1'b0;
            }
        }
    }

    assign adj_param_ready = adj_calc_valid;


    // output
    always_ff (clk, reset) {
        if_reset {
            adjust_sign  = 'x;
            adjust_valid = 1'b0;
        } else {
            if adjust_ready {
                adjust_valid = 1'b0;
            }

            if adj_calc_valid {
                adjust_sign  = adj_calc_sign;
                adjust_valid = ~adj_calc_zero;
            }
        }
    }

    if DEBUG :debug_monitor {
        #[sv("mark_debug=\"true\"")]
        var dbg_current_time: logic<TIMER_WIDTH>;
        #[sv("mark_debug=\"true\"")]
        var dbg_correct_override: logic;
        #[sv("mark_debug=\"true\"")]
        var dbg_correct_time: logic<TIMER_WIDTH>;
        #[sv("mark_debug=\"true\"")]
        var dbg_correct_valid: logic;
        #[sv("mark_debug=\"true\"")]
        var dbg_error_adjust_value: t_error;
        #[sv("mark_debug=\"true\"")]
        var dbg_diff_time: signed logic<TIMER_WIDTH>;
        #[sv("mark_debug=\"true\"")]
        var dbg_diff_time_abs: logic<TIMER_WIDTH>;
        #[sv("mark_debug=\"true\"")]
        var dbg_error_estimate_x : t_error   ;
        #[sv("mark_debug=\"true\"")]
        var dbg_error_estimate_v : t_error   ;
        #[sv("mark_debug=\"true\"")]
        var dbg_error_estimate_x0 : t_error   ;
        #[sv("mark_debug=\"true\"")]
        var dbg_error_estimate_v0 : t_error   ;

        #[sv("mark_debug=\"true\"")]
        var dbg_cycle_observe_t        : t_cycle;
        #[sv("mark_debug=\"true\"")]
        var dbg_cycle_predict_t        : t_cycle;
        #[sv("mark_debug=\"true\"")]
        var dbg_cycle_estimate_t       : t_cycle;
        #[sv("mark_debug=\"true\"")]
        var dbg_cycle_estimate_t0      : t_cycle;


        var dbg_diff_time_tmp: signed logic<TIMER_WIDTH>;
        assign dbg_diff_time_tmp = correct_time - current_time;

        always_ff (clk) {
            dbg_current_time       = current_time;
            dbg_correct_override   = correct_override;
            dbg_correct_time       = correct_time;
            dbg_correct_valid      = correct_valid;
            dbg_error_adjust_value = error_adjust_value;
            dbg_diff_time          = dbg_diff_time_tmp;
            dbg_diff_time_abs      = if dbg_diff_time_tmp >= 0 { dbg_diff_time_tmp }  else { -dbg_diff_time_tmp };
            dbg_error_estimate_x   = error_estimate_x;
            dbg_error_estimate_v   = error_estimate_v;
            dbg_error_estimate_x0  = error_estimate_x0;
            dbg_error_estimate_v0  = error_estimate_v0;
            dbg_cycle_observe_t    = cycle_observe_t  ;
            dbg_cycle_predict_t    = cycle_predict_t  ;
            dbg_cycle_estimate_t   = cycle_estimate_t ;
            dbg_cycle_estimate_t0  = cycle_estimate_t0;

        }
    }

    if SIMULATION :sim_monitor {
        var sim_monitor_cycle_estimate_t    : real;
        var sim_monitor_error_observe_x     : real; // 位相誤差の観測値
        var sim_monitor_error_predict_x     : real; // 位相誤差の予測値
        var sim_monitor_error_predict_x_gain: real; // 位相誤差の予測値にゲインを掛けたもの
        var sim_monitor_error_estimate_x    : real; // 位相誤差の推定値
        var sim_monitor_error_estimate_x0   : real; // １つ前の位相誤差の推定値
        var sim_monitor_error_observe_v     : real; // 周期誤差の観測値
        var sim_monitor_error_predict_v     : real; // 位相誤差の予測値
        var sim_monitor_error_predict_v_gain: real; // 周期誤差の予測値にゲインを掛けたもの
        var sim_monitor_error_estimate_v    : real; // 周期誤差の推定値
        var sim_monitor_error_estimate_v0   : real; // １つ前の周期誤差の推定値
        var sim_monitor_error_adjust_value  : real;
        var sim_monitor_adj_param_period    : real;
        var sim_monitor_debug_count         : real;

        assign sim_monitor_cycle_estimate_t     = $itor(cycle_estimate_t) / $itor(2 ** CYCLE_Q);
        assign sim_monitor_error_observe_x      = $itor(error_observe_x) / $itor(2 ** ERROR_Q);
        assign sim_monitor_error_predict_x      = $itor(error_predict_x) / $itor(2 ** ERROR_Q);
        assign sim_monitor_error_predict_x_gain = $itor(error_predict_x_gain) / $itor(2 ** ERROR_Q);
        assign sim_monitor_error_estimate_x     = $itor(error_estimate_x) / $itor(2 ** ERROR_Q);
        assign sim_monitor_error_estimate_x0    = $itor(error_estimate_x0) / $itor(2 ** ERROR_Q);
        assign sim_monitor_error_observe_v      = $itor(error_observe_v) / $itor(2 ** ERROR_Q);
        assign sim_monitor_error_predict_v      = $itor(error_predict_v) / $itor(2 ** ERROR_Q);
        assign sim_monitor_error_predict_v_gain = $itor(error_predict_v_gain) / $itor(2 ** ERROR_Q);
        assign sim_monitor_error_estimate_v     = $itor(error_estimate_v) / $itor(2 ** ERROR_Q);
        assign sim_monitor_error_estimate_v0    = $itor(error_estimate_v0) / $itor(2 ** ERROR_Q);
        assign sim_monitor_error_adjust_value   = $itor(error_adjust_value) / $itor(2 ** ERROR_Q);
        assign sim_monitor_adj_param_period     = $itor(adj_param_period) / $itor(2 ** ADJUST_Q);
        assign sim_monitor_debug_count          = sim_monitor_cycle_estimate_t / sim_monitor_adj_param_period;
    }

}
